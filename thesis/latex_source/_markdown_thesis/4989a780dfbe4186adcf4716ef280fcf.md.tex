\markdownRendererHeadingOne{C-RAN for LoRa}\markdownRendererInterblockSeparator
{}An arduino with a LoRa shield sends out packets over the air in an interval. Some packets require an acknowledgment (ACK). If an ACK is required, the arduino waits for a certain amount of time for the ACK. If the ACK arrives in time, the arduino starts transmitting the next packet. If not, the arduino will resend the packet and again wait for the ACK.\markdownRendererInterblockSeparator
{}The RRH (Remote Radio Head) receives radio waves with a LimeSDR. The RRH streams the IQ samples over the network the the BBU (Base Band Unit).\markdownRendererInterblockSeparator
{}The BBU decodes the message. If the message says it require and ACK, the BBU send out IQ samples of the ACK message over the network to the RRH which transmits them back over the air to the arduino.\markdownRendererInterblockSeparator
{}\markdownRendererHeadingTwo{Run with Docker}\markdownRendererInterblockSeparator
{}\markdownRendererOlBeginTight
\markdownRendererOlItemWithNumber{1}Clone the repo\markdownRendererOlItemEnd 
\markdownRendererOlItemWithNumber{2}Go to the docker directory\markdownRendererOlItemEnd 
\markdownRendererOlEndTight \markdownRendererInterblockSeparator
{}\markdownRendererHeadingThree{\markdownRendererStrongEmphasis{\markdownRendererEmphasis{Info}}}\markdownRendererInterblockSeparator
{}\markdownRendererUlBeginTight
\markdownRendererUlItem The container run in priviledged mode to easily access plugged in USB devices\markdownRendererUlItemEnd 
\markdownRendererUlItem The container run in network mode host (No NAT or Bridge has to be considered). This means the containers have the ip address of the host machine. If RRH and BBU run on different machines, find out their respective IP with \markdownRendererEmphasis{ifconfig} and pass the address as arguments in the docker-compose.yml, see below.\markdownRendererUlItemEnd 
\markdownRendererUlEndTight \markdownRendererInterblockSeparator
{}\markdownRendererHorizontalRule{}\markdownRendererInterblockSeparator
{}\markdownRendererHeadingTwo{RRH}\markdownRendererInterblockSeparator
{}In the RRH directory run:\markdownRendererInterblockSeparator
{}\markdownRendererCodeSpan{
docker-compose up 
}\markdownRendererInterblockSeparator
{}This starts the Remote Radio Head. The RRH looks for a LimeSDR, it prints errors if it cannot find one. You can plug one in after the container has started and it should get detectet. By default it uses the first LimeSDR it can find.\markdownRendererInterblockSeparator
{}\markdownRendererHeadingThree{Parameters}\markdownRendererInterblockSeparator
{}There are various parameters which you can specify in the \markdownRendererEmphasis{docker-compose.yml} file.\markdownRendererInterblockSeparator
{}Run this to see what the possible params are: \markdownRendererCodeSpan{
./zero\markdownRendererUnderscore{}mq\markdownRendererUnderscore{}split\markdownRendererUnderscore{}a.py -h
}\markdownRendererInterblockSeparator
{}Output: ``` Usage: zero\markdownRendererEmphasis{mq}split\markdownRendererUnderscore{}a.py: [options]\markdownRendererInterblockSeparator
{}Options: -h, --help show this help message and exit --RX-device-serial=RX\markdownRendererEmphasis{DEVICE}SERIAL Set RX\markdownRendererEmphasis{device}serial [default=] --TX-device-serial=TX\markdownRendererEmphasis{DEVICE}SERIAL Set TX\markdownRendererEmphasis{device}serial [default=] --capture-freq=CAPTURE\markdownRendererEmphasis{FREQ Set capture}freq [default=868.5M] --samp-rate=SAMP\markdownRendererEmphasis{RATE Set samp}rate [default=1.0M] --zmq-address-iq-in=ZMQ\markdownRendererEmphasis{ADDRESS}IQ\markdownRendererEmphasis{IN Set zmq}address\markdownRendererEmphasis{iq}in [default=tcp://127.0.0.1:5052] --zmq-address-iq-out=ZMQ\markdownRendererEmphasis{ADDRESS}IQ\markdownRendererEmphasis{OUT Set zmq}address\markdownRendererEmphasis{iq}out [default=tcp://*:5051]\markdownRendererInterblockSeparator
{}```\markdownRendererInterblockSeparator
{}\markdownRendererPipe{} Param \markdownRendererPipe{} Explanation \markdownRendererPipe{} \markdownRendererPipe{} ------------- \markdownRendererPipe{} ------------- \markdownRendererPipe{} \markdownRendererPipe{} RX-device-serial \markdownRendererPipe{} By default, the program will use the first LimeSDR it can find for receiving and transmitting signal. If you have two devices you can specify which should receive by passing the device Serial (See section \markdownRendererStrongEmphasis{Help} for more info) \markdownRendererPipe{} \markdownRendererPipe{} TX-device-serial \markdownRendererPipe{} By default, the program will use the first LimeSDR it can find for receiving and transmitting signal. If you have two devices you can specify which should transmit by passing the device Serial (See section \markdownRendererStrongEmphasis{Help} for more info) \markdownRendererPipe{} \markdownRendererPipe{}capture-freq\markdownRendererPipe{}The frequency in Hz at which the RRH listens for signals. Default value is 86850000\markdownRendererPipe{} \markdownRendererPipe{}samp-rate\markdownRendererPipe{}How many samples per second. Default value is 1000000. Must be at least double the bandwidth of the expected signal see \markdownRendererEmphasis{Nyquist-Shannon principle}\markdownRendererPipe{} \markdownRendererPipe{}zmq-address-iq-in\markdownRendererPipe{} ZMQ address to which the RRH subscribes to receive an IQ samples stream (from the BBU) to then send out (TX). Default value is tcp://127.0.0.1:5052 meaning the IQ samples are expected to come from localhost on port 5052. Normally RRH and BBU are on different devices but on the same network \markdownRendererPipe{} \markdownRendererPipe{}--zmq-address-iq-out\markdownRendererPipe{}ZMQ address on which the RRH streams out the IQ samples (to the BBU) it receives (RX). Default is tcp://*:5051 meaning it publishes the stream on all interface on port 5051\markdownRendererPipe{}\markdownRendererInterblockSeparator
{}--- To pass the parameters you have to specify them in the docker-compose.yml\markdownRendererInterblockSeparator
{}Example: \markdownRendererInterblockSeparator
{}To pass a capture frequencey of 915M and a sample rate of 250k enter the params in the following way in the command field:\markdownRendererInterblockSeparator
{}\markdownRendererEmphasis{docker-compose.yml} \markdownRendererCodeSpan{
version: '3'
services:
    rrh:
        build: .
        privileged: true
        network\markdownRendererUnderscore{}mode: host
        volumes:
                - /dev/bus/usb:/dev/bus/usb
        command: ["--capture-freq", "915000000", "--samp\markdownRendererUnderscore{}rate", "250000"]
}\markdownRendererInterblockSeparator
{}---\markdownRendererInterblockSeparator
{}\markdownRendererHeadingTwo{BBU}\markdownRendererInterblockSeparator
{}The BBU has two components: * LoRa\markdownRendererEmphasis{Decoder: receives a stream of IQ samples from the RRH, decodes the LoRa signal and sends the decoded message out on a UDP socket * LoRa}Responder: receives the messages from that UDP socket and, depending on message content, streams response IQ samples to the RRH or does not give a response\markdownRendererInterblockSeparator
{}In the BBU directory run:\markdownRendererInterblockSeparator
{}\markdownRendererCodeSpan{
docker-compose up 
}\markdownRendererInterblockSeparator
{}This starts both components of the BBU\markdownRendererInterblockSeparator
{}\markdownRendererHeadingThree{Params}\markdownRendererInterblockSeparator
{}The LoRa\markdownRendererUnderscore{}Decoder has the following params:\markdownRendererInterblockSeparator
{}``` Usage: zero\markdownRendererEmphasis{mq}split\markdownRendererUnderscore{}b.py: [options]\markdownRendererInterblockSeparator
{}Options: -h, --help show this help message and exit --bandwidth=BANDWIDTH Set bandwidth [default=125000] --capture-freq=CAPTURE\markdownRendererEmphasis{FREQ Set capture}freq [default=868.5M] --decoded-out-port=DECODED\markdownRendererEmphasis{OUT}PORT Set decoded\markdownRendererEmphasis{out}port [default=40868] --samp-rate=SAMP\markdownRendererEmphasis{RATE Set samp}rate [default=1.0M] --spreading-factor=SPREADING\markdownRendererEmphasis{FACTOR Set spreading}factor [default=12] --zmq-address-iq-in=ZMQ\markdownRendererEmphasis{ADDRESS}IQ\markdownRendererEmphasis{IN Set zmq}address\markdownRendererEmphasis{iq}in [default=tcp://127.0.0.1:5051]\markdownRendererInterblockSeparator
{}``` \markdownRendererPipe{} Param \markdownRendererPipe{} Explanation \markdownRendererPipe{} \markdownRendererPipe{} ------------- \markdownRendererPipe{} ------------- \markdownRendererPipe{} \markdownRendererPipe{} bandwith \markdownRendererPipe{} The bandwidth in Hz of the LoRa signal. Default is 125000. \markdownRendererPipe{} \markdownRendererPipe{} capture-freq \markdownRendererPipe{} The frequency in Hz of the LoRa signal. The RRH of course must also listen on this frequeny. Default is 868500000. \markdownRendererPipe{} \markdownRendererPipe{}decoded-out-port\markdownRendererPipe{}On which port the decoded messages will be sent out. Localhost only. The LoRa\markdownRendererUnderscore{}Responder needs to be configured to listen on this port. Default is 40868.\markdownRendererPipe{} \markdownRendererPipe{}samp-rate\markdownRendererPipe{} How many samples per second to expect from the RRH. Default is 1000000\markdownRendererPipe{} \markdownRendererPipe{}spreading-factor\markdownRendererPipe{} The spreading factor of the incoming LoRa signal. From [7-12] inclusive. Default is 12 \markdownRendererPipe{} \markdownRendererPipe{}--zmq-address-iq-in\markdownRendererPipe{}ZMQ address to which the BBU subscribes to receive an IQ samples stream (from the RRH) to decode. Default value is tcp://127.0.0.1:5051 meaning the IQ samples are expected to come from localhost on port 5051. Normally RRH and BBU are on different devices but on the same network\markdownRendererPipe{}\markdownRendererInterblockSeparator
{}\markdownRendererHorizontalRule{}\markdownRendererInterblockSeparator
{}The LoRa\markdownRendererUnderscore{}Responder has the following params:\markdownRendererInterblockSeparator
{}``` usage: lora\markdownRendererEmphasis{socket}server.py [-h] [-o OUT\markdownRendererUnderscore{}PORT] [-i INPUT\markdownRendererUnderscore{}PORT]\markdownRendererInterblockSeparator
{}Connect to udp port for receiving decoded LoRa signals, if an ACK is required publish ACK iq samples via zmq socket for Remote Radio Head to receive and send out (TX).\markdownRendererInterblockSeparator
{}optional arguments: -h, --help show this help message and exit -o OUT\markdownRendererEmphasis{PORT, --out-port OUT}PORT zmq port to publish downstream (i.e ACK) iq samples (default: 5052) -i INPUT\markdownRendererEmphasis{PORT, --input-port INPUT}PORT UDP port to connect for receiving decoded lora messages (default: 40868)\markdownRendererInterblockSeparator
{}```\markdownRendererInterblockSeparator
{}\markdownRendererPipe{} Param \markdownRendererPipe{} Explanation \markdownRendererPipe{} \markdownRendererPipe{} ------------- \markdownRendererPipe{} ------------- \markdownRendererPipe{} \markdownRendererPipe{} out-port \markdownRendererPipe{} Publish the response IQ samples on all interface on this port. Default is 5052. (The response is 3 bytes long ("ACK") and SF 12. This is hardcoded for now)\markdownRendererPipe{}\markdownRendererInterblockSeparator
{}\markdownRendererHeadingTwo{\markdownRendererPipe{}input-port\markdownRendererPipe{} UDP port to receive the decoded messages sent by the LoRa\markdownRendererUnderscore{}Decoder. Default is 40868\markdownRendererPipe{}}\markdownRendererInterblockSeparator
{}To pass the parameters you have to specify them in the docker-compose.yml file.\markdownRendererInterblockSeparator
{}Example: \markdownRendererInterblockSeparator
{}To have the LoRa\markdownRendererEmphasis{Decoder send the decoded messages out on port 30300 and the Lora}Responder to listen on port 30300 accordingly pass the arguments like below to the respective command field: \markdownRendererInterblockSeparator
{}\markdownRendererEmphasis{docker-compose.yml} \markdownRendererCodeSpan{
version: '3'
services:
        lora\markdownRendererUnderscore{}decoder:
                build: ./LoRa\markdownRendererUnderscore{}Decoder
                network\markdownRendererUnderscore{}mode: host
                tty: true
                command: ["--decoded-out-port", "30300"]
        lora\markdownRendererUnderscore{}responder:
                build: ./LoRa\markdownRendererUnderscore{}Responder
                network\markdownRendererUnderscore{}mode: host
                tty: true
                command: ["--input-port", "30300"] 
}\markdownRendererInterblockSeparator
{}\markdownRendererHeadingTwo{LimeSDR}\markdownRendererInterblockSeparator
{}\markdownRendererUlBeginTight
\markdownRendererUlItem Plug in the antennas on the LimeSDR board on \markdownRendererEmphasis{RX1\markdownRendererUnderscore{}L} and \markdownRendererEmphasis{TX1\markdownRendererUnderscore{}1}\markdownRendererUlItemEnd 
\markdownRendererUlEndTight \markdownRendererInterblockSeparator
{}\markdownRendererHeadingTwo{Help}\markdownRendererInterblockSeparator
{}\markdownRendererUlBegin
\markdownRendererUlItem LimeSDR calibration/gain error: \markdownRendererUlItemEnd 
\markdownRendererUlItem \markdownRendererLink{Download LimeSuite Toolkit}{https://wiki.myriadrf.org/Lime\markdownRendererUnderscore{}Suite}{https://wiki.myriadrf.org/Lime_Suite}{} to calibrate the LimeSDR\markdownRendererUlItemEnd 
\markdownRendererUlItem LimeSDR find device serial:\markdownRendererUlItemEnd 
\markdownRendererUlItem With LimeSuite installed run \markdownRendererEmphasis{LimeUtil --find}\markdownRendererUlItemEnd 
\markdownRendererUlItem Or run \markdownRendererEmphasis{lsusb -v} and look for the LimeSDR device\markdownRendererUlItemEnd 
\markdownRendererUlEnd \markdownRendererInterblockSeparator
{}\markdownRendererHorizontalRule{}\markdownRendererInterblockSeparator
{}\markdownRendererHeadingOne{Arduino}\markdownRendererInterblockSeparator
{}\markdownRendererStrongEmphasis{The arduino-lmic library is required \markdownRendererLink{Instructions here}{https://github.com/matthijskooijman/arduino-lmic}{https://github.com/matthijskooijman/arduino-lmic}{}}\markdownRendererInterblockSeparator
{}\markdownRendererOlBeginTight
\markdownRendererOlItemWithNumber{1}Go to the arduino directory. \markdownRendererOlItemEnd 
\markdownRendererOlItemWithNumber{2}Compile and upload the code to the arduino\markdownRendererOlItemEnd 
\markdownRendererOlItemWithNumber{3}The arduino runs the protocol in the manner described at the beginning.\markdownRendererOlItemEnd 
\markdownRendererOlItemWithNumber{4}It send packets with SF12 and expects the ACK response to be SF12 as well.\markdownRendererOlItemEnd 
\markdownRendererOlItemWithNumber{5}After 3 packets the arduino has finished.\markdownRendererOlItemEnd 
\markdownRendererOlItemWithNumber{6}Look at the Serial output for details. Baud rate 9600\markdownRendererOlItemEnd 
\markdownRendererOlEndTight \markdownRendererInterblockSeparator
{}\markdownRendererStrongEmphasis{Info}\markdownRendererInterblockSeparator
{}PlatformIO was used to compile and upload the image to the arduino.\markdownRendererInterblockSeparator
{}\markdownRendererHorizontalRule{}\markdownRendererInterblockSeparator
{}\markdownRendererHeadingTwo{Manual installation Ubuntu}\markdownRendererInterblockSeparator
{}Visit this guide for \markdownRendererLink{installing LimeSDR Plugin for GNU Radio}{https://wiki.myriadrf.org/Gr-limesdr\markdownRendererUnderscore{}Plugin\markdownRendererUnderscore{}for\markdownRendererUnderscore{}GNURadio}{https://wiki.myriadrf.org/Gr-limesdr_Plugin_for_GNURadio}{} for more detail. This guide only has the short version.\markdownRendererInterblockSeparator
{}Install dependencies for signal processing: \markdownRendererCodeSpan{
sudo apt-get update \markdownRendererAmpersand{}\markdownRendererAmpersand{} sudo apt-get install -y gnuradio=3.7.11-10 libboost-all-dev swig git cmake software-properties-common \markdownRendererBackslash{}
libcppunit-1.14-0 libfftw3-bin libvolk1-bin liblog4cpp5v5 python libliquid1d libliquid-dev python-pip \markdownRendererBackslash{}
\markdownRendererAmpersand{}\markdownRendererAmpersand{} pip install numpy \markdownRendererAmpersand{}\markdownRendererAmpersand{} pip install scipy
}\markdownRendererInterblockSeparator
{}Install LimeSuite \markdownRendererCodeSpan{
sudo add-apt-repository -y ppa:myriadrf/drivers \markdownRendererAmpersand{}\markdownRendererAmpersand{} sudo apt-get update \markdownRendererBackslash{}
\markdownRendererAmpersand{}\markdownRendererAmpersand{} sudo apt-get install -y limesuite liblimesuite-dev limesuite-udev limesuite-images \markdownRendererBackslash{}
soapysdr-tools soapysdr-module-lms7
} Clone and install LimeSDR Plugin for GNU Radio:\markdownRendererInterblockSeparator
{}\markdownRendererCodeSpan{
git clone https://github.com/myriadrf/gr-limesdr \markdownRendererAmpersand{}\markdownRendererAmpersand{} cd gr-limesdr \markdownRendererAmpersand{}\markdownRendererAmpersand{} mkdir build \markdownRendererAmpersand{}\markdownRendererAmpersand{} cd build \markdownRendererAmpersand{}\markdownRendererAmpersand{} cmake .. \markdownRendererAmpersand{}\markdownRendererAmpersand{} make \markdownRendererAmpersand{}\markdownRendererAmpersand{} sudo make install \markdownRendererAmpersand{}\markdownRendererAmpersand{} sudo ldconfig
}\markdownRendererInterblockSeparator
{}Clone and install rpp0's LoRa decoder for gnuradio \markdownRendererCodeSpan{
git clone https://github.com/rpp0/gr-lora.git \markdownRendererAmpersand{}\markdownRendererAmpersand{} cd gr-lora \markdownRendererAmpersand{}\markdownRendererAmpersand{} git checkout b1d38fab9032a52eaf31bf33a145df45fce7512f\markdownRendererBackslash{}
\markdownRendererAmpersand{}\markdownRendererAmpersand{} mkdir build \markdownRendererAmpersand{}\markdownRendererAmpersand{} cd build \markdownRendererBackslash{}
\markdownRendererAmpersand{}\markdownRendererAmpersand{} cmake .. \markdownRendererAmpersand{}\markdownRendererAmpersand{} make \markdownRendererAmpersand{}\markdownRendererAmpersand{} sudo make install \markdownRendererBackslash{}
\markdownRendererAmpersand{}\markdownRendererAmpersand{} cd .. \markdownRendererAmpersand{}\markdownRendererAmpersand{} rm -rf build \markdownRendererBackslash{}
\markdownRendererAmpersand{}\markdownRendererAmpersand{} git checkout -b encoder origin/encoder \markdownRendererAmpersand{}\markdownRendererAmpersand{} git checkout 3c9a63f1d148592df2b715496c67ccbc2939ad0d \markdownRendererBackslash{}
\markdownRendererAmpersand{}\markdownRendererAmpersand{} mkdir build \markdownRendererAmpersand{}\markdownRendererAmpersand{} cd build \markdownRendererBackslash{}
\markdownRendererAmpersand{}\markdownRendererAmpersand{} cmake .. \markdownRendererAmpersand{}\markdownRendererAmpersand{} make \markdownRendererAmpersand{}\markdownRendererAmpersand{} sudo make install \markdownRendererAmpersand{}\markdownRendererAmpersand{} sudo ldconfig
}\markdownRendererInterblockSeparator
{}With pip for python2 install the zmq package: \markdownRendererCodeSpan{
pip install pyzmq==18.1.0
}\markdownRendererInterblockSeparator
{}Then open the \markdownRendererEmphasis{zero\markdownRendererEmphasis{mq}split\markdownRendererEmphasis{a.grc* and the *zero}mq\markdownRendererEmphasis{split}b.grc} file in the docker/RRH directory resp. in the docker/BBU/LoRa\markdownRendererEmphasis{Decoder directory. Or run the \markdownRendererEmphasis{zero\markdownRendererEmphasis{mq}split\markdownRendererEmphasis{a.py* resp. the *zero}mq\markdownRendererEmphasis{split}b.py} script in those directories with your shell. Also run the \markdownRendererEmphasis{lora\markdownRendererEmphasis{socket}server.py} sript inside docker/BBU/LoRa}Responder with your shell.\markdownRendererInterblockSeparator
{}\markdownRendererHeadingOne{Tools}\markdownRendererInterblockSeparator
{}In the tools directory in the Encode and Decode directory are multiple usefuls scripts for encoding and decoding lora without gnuradio\markdownRendererInterblockSeparator
{}\markdownRendererOlBegin
\markdownRendererOlItemWithNumber{1}First, after you recorded a signal trim the signal with a tool like audacity. Else if you want to visualize it with plot\markdownRendererUnderscore{}signal.py the signal is shrunk too much to make it fit in the plot.\markdownRendererOlItemEnd 
\markdownRendererOlItemWithNumber{2}After trimming, channelize the signal else the decoder cannot properly decode the signal. Run channelizer.py -h to see the options. It takes an signal recording via the --input-file option and outputs the channelized file as "channelized.raw". Don't forget to specify bandwidth and sample rate if they differ from the set default values.\markdownRendererOlItemEnd 
\markdownRendererOlItemWithNumber{3}The channelized signal can the be passed to the decoder. The decoder prints out the decoded signal and generates a csv file (words.csv) containing the words at each sample. Don't forget to specify bandwidth and sample rate etc if they differ from the set default values.\markdownRendererOlItemEnd 
\markdownRendererOlItemWithNumber{4}This csv file can be passed to plot\markdownRendererUnderscore{}signal.py which draws the signal and the words in the csv file to a pdf (rawframe.pdf). Don't forget to specify bandwidth and sample rate if they differ from the set default values.\markdownRendererOlItemEnd 
\markdownRendererOlEnd \markdownRendererInterblockSeparator
{}Use the encoder to generate samples for the test\markdownRendererUnderscore{}packet[] uint8 array in the code. The samples are written to the fiel "output.bin"\markdownRendererInterblockSeparator
{}Use the two scripts decoder\markdownRendererEmphasis{build.sh and encoder}build.sh to compile the encode.cc and decode.cc files. \markdownRendererInterblockSeparator
{}Use VsCode to open the directory "Encode and Decode" to have predefiend debug configurations. The folder '.vscode' has been commited in this repo.\markdownRendererInterblockSeparator
{}All recorded uplink signals have been recorded with sample rate 1Million and transmitted with a bandwidth of 125'000\markdownRendererInterblockSeparator
{}The decoder only works for signals with an explicit header.\relax