\chapter{C-RAN for LoRa}
\label{chap:cran_for_lora}

\section{Goal}
The goal is to set up a minimal working environment for a LoRa C-RAN.
The gateway's functionality should separated into an RRH and BBU component and the 
BBU component should be virtualized and run on general purpose hardware. 
A simple network server should process the uplink message and schedule a response if required. From this setup 
basic network requirements can be derived and measured as well as costs estimated.

\section{Methods}

\begin{figure}
    \centering
    \begin{subfigure}[b]{0.25\textwidth}
     \includegraphics[width=1\textwidth]{figures/arduino.png}
     \caption{Arduino with LoRa shield}
     \label{fig:ard}
    \end{subfigure}%
    \hspace{2em}
    \begin{subfigure}[b]{0.25\textwidth}
     \includegraphics[width=1\textwidth]{figures/limesdr.png}
     \caption{LimeSDR mini}
     \label{fig:sdr}
    \end{subfigure}
    \hspace{2em}
    \begin{subfigure}[b]{0.25\textwidth}
     \includegraphics[width=1\textwidth]{figures/raspberry.png}
     \caption{Raspberry Pi with LoRa hat}
     \label{fig:rasp}
    \end{subfigure}
    \caption{Hardware devices}
   \end{figure}
\subsection{Sending uplink signals}
Uplink signals are sent with an arduino device equipped with a LoRa shield. 
The arduino is controlled with an adapted form of the IBM LoraMAC-in-C (LMIC) library, modified to run on arduino devices.
Using this library we implemented a simple communication protocol where a queue of packets is sent out in an interval.
See section~\ref{sec:comm_prot} for detailed information.
% \url{https://github.com/matthijskooijman/arduino-lmic}.
\subsection{RRH and BBU}
For splitting up the LoRa gateway's functionality we use two laptops. 
One laptop has the LimeSDR mini plugged in and serves as the RRH. The other decodes the LoRa
signal in software, processes the signal and also generates LoRa signals in software and sends those downlink I/Q samples back to the RRH.
The processes on the second laptop run in virtualized environment with docker, more specifically docker compose, dockers orchestration tool.
\\
The LoRa OOT module by Robyns et al. has a branch called "encoder" where they began the implementation of modulating an uplink LoRa signal in software.
It is able to generate a specific test packet but the modulated signal has errors as we saw when we inspected the data payload on the LoRa gateway.
Having an uplink signal generator was a nice starting point, but we needed something to generate downlink signal. In the end we extended the existing implementation
by adding a downlink signal generation ability, see section~\ref{todo}.
\\
Though, as a first workaround we set up a private LoRaWAN network, scheduled a downlink, and recorded it to a file. Now we can stream that file as a response by streaming its content,
which are I/Q samples, to the RRH.


\subsection{Network Tools}
For measuring network traffic, the tool "bmon" is used which stands for bandwidth monitor.
It estimates the bits per second on all available network interfaces, ingoing as well as outgoing. 
For adding network delay we used the tool "netem" which stands for network emulator. With netem we can add a delay to the qdisc scheduler
which controls the processing the IP packets sent over the ethernet network interface.
Both tools can easily be install with the "apt" package manager for ubuntu.

\subsection{Hardware}
An Arduino Mega 2560 with the Dragion LoRa Shield v1.4 is the end device, see Figure~\ref{fig:ard}.
A LimeSDR mini, Figure~\ref{fig:sdr}, serves as the receiver for the RRH.
The Raspberry Pi, Figure~\ref{fig:rasp} with a LoRa hat was used for testing up -and downlink signals, but not for the experiment itself. 
Its hat is the iC880A LoRaWAN concentrator for the 868MHz frequency.
\newpage
% getting a downlink signal
% recording from thethingsnetwrok
% recording from private networks
% manipualting private gateway
% offline generation of downlink signal see chapter



\section{Architecture}
This section aims to first give a high level overview of the architecture and then give a more detailed 
architectural overview of each component.
Figure~\ref{fig:high_level_arch} shows the high level architecture with all the hardware components involved.
There are two laptops in the same network connected by an ethernet cable. One laptop serves as an RRH. It has the LimeSDR mini 
plugged into its USB port so it can send and receive signals.
\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{figures/high_level_arch.png}
    \caption{High level architecture}
    \label{fig:high_level_arch}
\end{figure}
Incoming signals come from the arduino device. The arduino transmits packets over the air as radio waves. Those get picked up 
by the RRH which converts the analog signal and send them as digital 32bit floats as I/Q samples over ethernet to the second laptop.
This second laptop is the host for the virtual BBU that runs in a docker container. There the signals get demodulated and decoded.
Then the decoded signal gets processed. In case a response is requested, a response signal is generated and sent as I/Q samples back to the RRH.
From the it gets transmitted back to the arduino.
\subsection{RRH and BBU}
The RRH is the simplest component. It has an antenna for input and one for output. In Figure~\ref{fig:seq_diagram} the RRH is composed by the two 
components "SDR RX" and "SDR TX". They correspond to the physical RX and TX slots ond the SDR device. The BBU is the "Lora Decoder" component. It runs 
in a virtualized environment. Decoded messages get passed to the "Python Script" component. This acts as a network server that schedules an acknowledgement
message back to the arduino. It could run on a third laptop connected via ethernet to the BBU laptop, but for our purposes it runs on the same laptop
as the BBU but in a separate docker container.
\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{figures/seq_diagram.png}
    \caption{Sequence diagram}
    \label{fig:seq_diagram}
\end{figure}


\section{Implementation}
All communication between the components happens over sockets. We use the ZeroMQ (ZMQ) networking library.
It is a good messaging library that offers N-to-N patterns as possible ways to connect the sockets, such as a request-reply pattern
or pub-sub pattern and many more~\cite{zeromq}.
GNU Radio offers ZMQ blocks out of the box, The TCP sink and source blocks for socket communication are still available but deprecated. 
For communication between the RRH and the BBU the pub-sub (publish-subscribe) pattern is used.
Figure~\ref{fig:seq_diagram} shows the "PUB" and "SUB" blocks and the data flow.
The RRH has a PUB sockets that takes as input the I/Q sample stream generated by the RX of the SDR.
The SUB socket in the BBU subscribes to this publishing socket. As this socket connection happens with TCP, the I/Q samples arrive in the order
they are sent an can be directly passed to the LoRa Decoder. Robyns' et al. implementation of LoRa Decoder sends the decoded message 
out on a UDP socket.  The "Python Script" block which is our LoRa network server takes the decoded messages over on this UDP socket and then, streams out 
I/Q samples of the response message over a ZMQ publishing socket to which the RRH's TX slot subscribes to. This closes the cycle.
One of the advantages of using ZMQ is that the sockets can be given the option to not time out or close. This means a subscribing socket 
can be started before a publishing socket without issues. The subscribing socket can wait for the publishing socket to get instantiated. For our architecture 
this means the docker containers for the RRH and BBU can be started in any order and more instances of the BBU can be added at runtime. The sub-pub pattern 
allows new subscribers and publisher to join.

\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{figures/impl_diagram.png}
    \caption{Socket communication between components}
    \label{fig:impl_diagram}
\end{figure}

\subsection{RRH}
The RRH implementation is straightforward. Figure~\ref{fig:RRH_impl} show the necessary 
GNU Radio blocks. On the left is the RX block of the LimeSDR that streams the incoming signals to the 
PUB socket. The response message from the networks server to send out comes through a SUB socket which 
streams directly to the TX block of the LimeSDR on the far right of the Figure.
The parameter blocks allow the passing of command line arguments to the resulting application to configure
the socket addresses if necessary. As there is a OOT module needed for GNU Radio to work with the LimeSDR, a the 
RRH comes also in a docker container to quickly get started as the necessary dependencies have all been installed
in that container.
\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{figures/RRH_impl.png}
    \caption{GNU Radio blocks for the RRH}
    \label{fig:RRH_impl}
\end{figure}

\subsection{BBU}
The BBU as shown in Figure~\ref{fig:BBU_impl} takes in the RX stream of the RRH on a SUB socket,
passes the I/Q samples to the LoRa decoder. The decoder decodes LoRa signal and outputs them as a 
message on the message socket sink, far right in the Figure.


\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{figures/BBU_impl.png}
    \caption{GNU Radio blocks for the BBU}
    \label{fig:BBU_impl}
\end{figure}

The python script which acts as our network server, inspects the message payload and if an 
acknowledgement is required by the sender it generates the response signal. 
Listing~\ref{lst:python_code} shows an excerpt of that python script.
The acknowledgement message is a recording of a LoRa downlink signal. Its I/Q samples get read into memory.
The script connects to the UDP socket. As the BBU component and this python script run on the same host, it connects
to 127.0.0.1, the port is passed as argument to the script. As the focus lies on the split between RRH and BBU we decided
to hard code the IP address to localhost for the LoRa decoder and the network server as they run on the same machine as depicted 
in Figure~\ref{fig:impl_diagram}. 
Then, in an endless loop, data gets received from the socket. The buffer size is 1024 bytes.
Whenever "ACK" is in the message payload, the acknowledgement signal get streamed out over a ZMQ publishing socket.
\\
The BBU and the network server run each in a container started with docker compose.


\begin{listing}[H]
\begin{minted}[frame=single,linenos=false]{python}
import zmq
import socket
...
with open (dir_path + "/ACK_DOWN_SF12_CR4.raw") as f:
    ack = f.read()
...
zmq_socket = context.socket(zmq.PUB)
...
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.bind(("127.0.0.1", udp_port))
print ('listen for decoded lora packages on udp port ' + str(udp_port))
while True:
    data, addr = s.recvfrom(1024)

    if ("ACK" in data):
        zmq_socket.send(ack) 
    else:
        print ("received package requests no ACK")
     
    
    \end{minted}
    \caption{Excerpt of the python script that functions as the network server}
    \label{lst:python_code}
\end{listing}

\subsection{Communication Protocol Arduino}
\label{sec:comm_prot}

The LMIC library runs a loop that executes jobs scheduled to run at a specified time. 
In the \emph{setup()} function that runs once when the arduino starts settings such as 
the spreading factor, frequency and coding rate are set. The frequency is given in Hertz and the the datarate 
is set with a predefined enum from the LMIC library. Also, the initial job for the LMIC is initialized there, see 
Listing~\ref{lst::ard_setup} last line.

\begin{listing}[H]
    \begin{minted}[frame=single]{c++}
void setup() {
  Serial.begin(9600);
  ...
  // initialize runtime env
  os_init();
  ...
  // Set up these settings once, and use them for both TX and RX
  LMIC.freq = 868500000;
  LMIC.txpow = 27; // Maximum TX power
  LMIC.datarate = DR_SF12;
  // This sets CR 4/5, BW125 (except for DR_SF7B, which uses BW250)
  LMIC.rps = updr2rps(LMIC.datarate);

  Serial.println("Started");
  Serial.flush();

  // setup initial job
  os_setCallback(&txjob, my_tx_func);
}
    \end{minted}
    \caption{Arduino setup() function}
    \label{lst::ard_setup}
    
\end{listing}

The last line schedules the initial job  \emph{txjob} with the \emph{my\_tx\_func} function that gets run
on execution of the job, see~Listing~\ref{lst::ard_mytx}. It takes the the index of the packet to send, Listing~\ref{lst::packets}, and
checks if the packet has "ACK" appended. Then the transmit function \emph{tx(packet, callback)} gets executed. 
It takes a packet and a callback function that gets executed after the transmission is finished. 
If an "ACK" is present, the callback function is set to \emph{my\_txdone\_func}, if not it is set to \emph{my\_txdone\_no\_ack\_func}.
Finally, in line 16 in Listing\ref{lst::ard_mytx}, schedules itself to be run again after \emph{TX\_INTERVAL} which is 4 seconds.


\begin{listing}[H]
    \begin{minted}[frame=single]{c++}
#define TX_INTERVAL 4000

int currentPacketIndex = 0;
const int numOfPackets = 3;
char *myPackets[numOfPackets] = {
    "This is packet 1ACK", 
    "This is packet 2ACK", 
    "This is packet 3",
};
    \end{minted}
    \caption{Packets 1 and 2 have "ACK" appended in their payload, while packet 3 does not}
    \label{lst::packets}
    
\end{listing}


\begin{listing}[H]
    \begin{minted}[frame=single, linenos]{c++}
static void my_tx_func(osjob_t *job) {
if (currentPacketIndex < numOfPackets) {
    ...
    char lastThree[3];
    memcpy(lastThree, &myPackets[currentPacketIndex][length - 3], 3);
    const char ack[] = {'A', 'C', 'K'};
    if (!memcmp(lastThree, ack, 3)) {
        // send and start rx for receiving ACK
        Serial.print("transmitting packet with ACK, packet: ");
        tx(myPackets[currentPacketIndex], my_txdone_func);
    } else {
        // send and schedule next packet
        Serial.print("transmitting packet without ACK, packet: ");
        tx(myPackets[currentPacketIndex], my_txdone_no_ack_func);
    }
    os_setTimedCallback(&txjob, os_getTime() +
                            ms2osticks(TX_INTERVAL), my_tx_func);
    } else {
        Serial.println("No more packets to send, done");
    }
}
    \end{minted}
    \caption{\emph{my\_tx\_fun} function}
    \label{lst::ard_mytx}
\end{listing}

The difference between the callback functions passed to the transmission function is that one
waits to receive an acknowledgement while the other simply increases the \emph{currentPacketIndex}
so the next packet gets sent the next time \emph{my\_tx\_func} get called.
The callback to the RX function gets executed every time a packets is received.
Listing~\ref{lst::ard_myrx} shows the implementation. The response signal by sent
by the network server has the payload "ACK", which is three bytes. 
If the \emph{LMIC.dataLen} is three bytes, it is assumed it is the expected acknowledgement signal.
The \emph{currentPacketIndex} gets incremented and the next transmission job gets set up.
Else, the \emph{currentPacketIndex} does not get incremented so the same packet gets rescheduled 
for transmission and the RX function gets called again.


\begin{listing}[H]
    \begin{minted}[frame=single, linenos]{c++}
static void my_rx_func(osjob_t *job)
{
    if (LMIC.dataLen == 3)
    {
    Serial.println("Got ACK");
    // if we get our ACK, start with next transmission, 
    // reschedules transmission at half TX_INTERVAL
    currentPacketIndex++;
    os_setTimedCallback(&txjob, os_getTime()
                            + ms2osticks(TX_INTERVAL / 2), my_tx_func);
    }
    else
    {
    Serial.println("NOT AN ACK");
    // resend packet if no ACK received within 3*TX_INTERVAL,
    // reschedules transmission in 3* TX_INTERVAL
    os_setTimedCallback(&txjob, os_getTime() 
                            + ms2osticks(3 * TX_INTERVAL), my_tx_func);
    // listen again
    rx(my_rx_func);
    }
}
    \end{minted}
    \caption{RX function that checks for the response or reschedules the packet transmission}
    \label{lst::ard_myrx}
\end{listing}

\section{Results}
\subsection{Network Utilization}
Monitoring the network utilization with bmon yields 
335 bytes per second on the ethernet network interface when idle. Once the C-RAN gets started the network
utilization rises to 8MiB/s (Mebibytes) which are equal to 67’108’864 bits.
Bmon only gives an estimation. The theoretical value can be derived the following way:
\\
\begin{itemize}
    \item The LimeSDR had the sample rate set to 1 million samples per second by default.
    \item The type is of complex type of 32 bit, (I/Q) => 2 x 32 bit, which gives 64 million~bits/s
    \item MTU (Maximum Transmission Unit) on most systems is 1500 bytes.
    \item Overhead for TCP and IP is 20 bytes each => 40 bytes
    \item This gives a MSS (Maximum Segment Size) of 1460 bytes
    \item 64M bits ÷ (1460 bytes×8) = 5479.45 packets needed
    \item Total overhead: 5480 packets x (40 bytes x 8) = 175360 bits
    \item 64’000’000 bits + 1’753’600 bits = 65’753’600 bit/s = 7.8 MiB/s
\end{itemize}

The RRH is constantly sending samples to the BBU. It does not matter if the arduino 
sends 1 signal every 4 seconds or 40 signals per second, the network utilization stays the same
as the sample rate stays the same. The experiment worked without error with the 
10 gigabit ethernet connection, but it did not work over Wi-Fi connection.
The response signal sent from the BBU to the RRH did not arrive on the RRH.
\\
\\
\textbf{Optimization}: The load on the network can be reduced. According to the Nyquist-Shannon sampling theorem~\cite{Shannon1949}
a sufficient sampling rate $f_{s}$ for a signal with bandwidth $B$ is given by:
\begin{center}
    $f_{s} > 2*B$  
\end{center}

The signal bandwidth of the LoRa signal sent with the arduino is set to 125 kHz. Thus the minimum sampling frequency according to the formula above
is 250'000 samples per second which is a quarter of the previous sample rate of 1 million. This also quarters the network utilization from 8 MiB to 2 Mib, see Table~\ref{tabl:samprates}.
Lowering the sampling rate below the Nyquist-Shannon limit results in the signal not getting successfully decoded.
\begin{table}[H]
    \centering
    \begin{tabular}{ |p{3cm}|p{3cm}|p{3cm}|p{3cm}| }
        \hline
        \multicolumn{4}{|c|}{Sample Rates and Network Utilization} \\
        \hline
        Samples per second & Max. Signal Bandwidth& Network Utilization & Decode Success in Experiment\\
        \hline
        1'000'000  &500 kHz & 8 MiB/s    &yes\\
        500'000  &250 kHz & 4 MiB/s    &yes\\
        250'000&  125 kHz&  2 MiB/s  & yes\\
        125'000 & 62.5 kHz & 1 MiB7s & no\\
        \hline
       \end{tabular}
\caption{Sampling rates and network utilization}
\label{tabl:samprates}
\end{table}

LoRaWAN defines different regional parameters. In the EU SF 8 to SF 12 signals are sent with 125 kHz bandwidth, while SF 7
can be sent with 125 kHz or 250 kHz bandwidth. In the US on the other hand SF 7 to SF 12 can also be sent with
a 500 kHz bandwidth \cite{lora_wan_reg_params}.
This has to be taken into consideration when designing a LoRaWAN compliant C-RAN architecture.
The network load for decoding a 500 kHz bandwidth US signal is for times higher than a EU 125 kHz bandwidth signal.

\subsection{Cost}
LoRa gateways come in various prices. The low cost indoor commercial gateway by TTN costs around 70\$ while their higher end 
gateway sells for 300\$. Cheaper gateways can be built with and Arduino and a LoRa shield such as the Dragino shield (22\$).
The issue is that those are often based on the SX1272/SX1276 chips. While cheaper, those gateways are so called single channel 
gateways. They can only listen on one channel with one spreading factor. They are not LoRaWAN compliant~\cite{single_chan_gate}.
LoRaWAN compliant gateways can be built with a Raspberry Pi with a iC880A concentrator (130\$) which use the SX1301/SX1257 chips. They can receive packets
of sent with different spreading factors on up to 8 channels in parallel.
\\
The LoRa Decoder block of Robyns et al. does not yet support multichannel decoding. Spreading factor and center frequency
need to be set explicitly, making it a single channel gateway. The advantage of having a decoder in software is that new instances 
of the LoRa Decoder block can be added without additional hardware costs. As the BBU is containerized, starting up a new instance 
is as easy as instructing docker to start a new instance of the decoder and pass it the desired frequency and SF. This saves the costs of 
a LoRaWAN concentrator.




\chapter{LoRa Tools}

